# -*- coding: utf-8 -*-
"""LabAssignment1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10yUAeDjv-78SCnpkO_oTQiZCx1XVseUr

# Question **2**
"""

# Create dictionary
student = {
    "name": "Asif Nawaz",
    "age": 20,
    "roll_number": "CS101",
    "grade": "B"
}

# 1. Print all keys and values
print("All Keys:", student.keys())
print("All Values:", student.values())

# 2. Update the grade
student["grade"] = "A"
print("\nUpdated Grade:", student["grade"])

# 3. Add a new key 'email'
student["email"] = "asifnawaz@example.com"
print("\nAdded Email:", student["email"])

# 4. Delete 'roll_number'
del student["roll_number"]
print("\nDictionary after deletion:", student)

"""# **Q3**"""

import matplotlib.pyplot as plt

# Data
X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]

# Plot
plt.plot(X, Y, marker='o', color='blue')

# Add title and labels
plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")

# Add grid lines
plt.grid(True)

# Show the plot
plt.show()

"""# Water Jug Problem (BFS and DFS)**bold text**"""

from collections import deque
import time

# capacities
jug1, jug2, target = 4, 3, 2

def BFS():
    start = (0, 0)
    visited = set()
    queue = deque([(start, [])])
    while queue:
        (a, b), path = queue.popleft()
        if (a, b) in visited:
            continue
        visited.add((a, b))
        path = path + [(a, b)]
        if a == target or b == target:
            return path
        # Possible moves
        moves = [
            (jug1, b), (a, jug2), (0, b), (a, 0),
            (a - min(a, jug2 - b), b + min(a, jug2 - b)),
            (a + min(b, jug1 - a), b - min(b, jug1 - a))
        ]
        for m in moves:
            if m not in visited:
                queue.append((m, path))
    return None

def DFS():
    start = (0, 0)
    stack = [(start, [])]
    visited = set()
    while stack:
        (a, b), path = stack.pop()
        if (a, b) in visited:
            continue
        visited.add((a, b))
        path = path + [(a, b)]
        if a == target or b == target:
            return path
        moves = [
            (jug1, b), (a, jug2), (0, b), (a, 0),
            (a - min(a, jug2 - b), b + min(a, jug2 - b)),
            (a + min(b, jug1 - a), b - min(b, jug1 - a))
        ]
        for m in moves:
            if m not in visited:
                stack.append((m, path))
    return None

# Compare
start_time = time.time()
bfs_path = BFS()
bfs_time = time.time() - start_time

start_time = time.time()
dfs_path = DFS()
dfs_time = time.time() - start_time

print("BFS Path:", bfs_path)
print("DFS Path:", dfs_path)
print("\nSteps - BFS:", len(bfs_path), " DFS:", len(dfs_path))
print("Time - BFS:", round(bfs_time, 6), "s  DFS:", round(dfs_time, 6), "s")

"""# TASK #6: A **Search**"""

import heapq

# Maze representation (1 = wall, 0 = open)
maze = [
    [0, 1, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 1],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [1, 0, 1, 0, 0, 0],
]

start = (0, 0)   # A
goal = (5, 5)    # Y

# Heuristic (Manhattan Distance)
def h(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

# A* Search
def astar(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    open_set = []
    heapq.heappush(open_set, (0 + h(start, goal), 0, start, [start]))
    visited = set()

    while open_set:
        f, g, current, path = heapq.heappop(open_set)
        if current == goal:
            return path
        if current in visited:
            continue
        visited.add(current)
        x, y = current
        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 0:
                heapq.heappush(open_set, (g+1+h((nx, ny), goal), g+1, (nx, ny), path+[(nx, ny)]))
    return None

path = astar(maze, start, goal)
print("A* Path:", path)

"""# **Task 1 BFS graph**"""

from collections import deque

def bfs_tree(root):
    queue = deque([root])
    while queue:
        node = queue.popleft()
        print(node, end=" ")
        for child in tree.get(node, []):
            queue.append(child)

# Tree representation using dictionary
tree = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F']
}

print("BFS Traversal of Tree:")
bfs_tree('A')

"""# Task 1 **DFS** graph"""

def dfs_tree(node):
    print(node, end=" ")
    for child in tree.get(node, []):
        dfs_tree(child)

print("\nDFS Traversal of Tree:")
dfs_tree('A')