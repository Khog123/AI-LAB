# -*- coding: utf-8 -*-
"""Mid_Lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gHSXq1Q_S8ZUqZnDYjjxi7LkU7W1zVVy

# Write a Python program that finds a sequence of valid states to move everyone across the river safely using:   
1.**Breadth-First Search (BFS) **

2.**Depth-First Search (DFS)**

3.** A* Search Algorithm **
"""

from collections import deque
import heapq

# ---------- Helper Functions ----------

def is_valid_state(M_left, C_left):
    M_right = 3 - M_left
    C_right = 3 - C_left
    # Check boundaries
    if not (0 <= M_left <= 3 and 0 <= C_left <= 3):
        return False
    # Check missionary safety on both sides
    if (M_left > 0 and M_left < C_left) or (M_right > 0 and M_right < C_right):
        return False
    return True


def get_successors(state):
    M_left, C_left, boat = state
    successors = []
    moves = [(1,0),(2,0),(0,1),(0,2),(1,1)]  # possible people to move

    for M_move, C_move in moves:
        if boat == 'L':  # moving from left to right
            new_state = (M_left - M_move, C_left - C_move, 'R')
        else:             # moving from right to left
            new_state = (M_left + M_move, C_left + C_move, 'L')

        if is_valid_state(new_state[0], new_state[1]):
            successors.append(new_state)

    return successors

# ---------- BFS Implementation ----------

def bfs(start, goal):
    queue = deque([(start, [start])])
    visited = set([start])

    while queue:
        state, path = queue.popleft()

        if state == goal:
            return path

        for successor in get_successors(state):
            if successor not in visited:
                visited.add(successor)
                queue.append((successor, path + [successor]))

    return None

# ---------- DFS Implementation ----------

def dfs(start, goal):
    stack = [(start, [start])]
    visited = set([start])

    while stack:
        state, path = stack.pop()

        if state == goal:
            return path

        for successor in get_successors(state):
            if successor not in visited:
                visited.add(successor)
                stack.append((successor, path + [successor]))

    return None

# ---------- A* Search Implementation ----------

def heuristic(state):
    M_left, C_left, boat = state
    # Simple heuristic: number of people left to move / boat capacity
    return (M_left + C_left) / 2

def a_star(start, goal):
    open_list = []
    heapq.heappush(open_list, (0 + heuristic(start), 0, start, [start]))
    visited = set()

    while open_list:
        f, g, state, path = heapq.heappop(open_list)

        if state == goal:
            return path

        if state in visited:
            continue
        visited.add(state)

        for successor in get_successors(state):
            if successor not in visited:
                new_g = g + 1
                new_f = new_g + heuristic(successor)
                heapq.heappush(open_list, (new_f, new_g, successor, path + [successor]))

    return None

# ---------- Now Running all algorithms ----------

start_state = (3, 3, 'L')
goal_state = (0, 0, 'R')

print("=== Breadth-First Search ===")
bfs_path = bfs(start_state, goal_state)
for step in bfs_path:
    print(step)

print("\n=== Depth-First Search ===")
dfs_path = dfs(start_state, goal_state)
for step in dfs_path:
    print(step)

print("\n=== A* Search Algorithm ===")
a_star_path = a_star(start_state, goal_state)
for step in a_star_path:
    print(step)